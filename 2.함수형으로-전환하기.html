<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>함수형으로 전환하기</title>
    <script src="./js/_.js" type="text/javascript"></script>
</head>

<body>

    <script>
        var users = [
            { id: 1, name: 'ID', age: 36 },
            { id: 2, name: 'BJ', age: 32 },
            { id: 3, name: 'JM', age: 32 },
            { id: 4, name: 'PJ', age: 27 },
            { id: 5, name: 'HA', age: 25 },
            { id: 6, name: 'JE', age: 26 },
            { id: 7, name: 'JI', age: 31 },
            { id: 8, name: 'MP', age: 23 }
        ]

        // 1. 명령형 코드
        // 1. 30세 이상인 users를 거른다.
        var temp_users = []
        for (var i = 0; i < users.length; i++) {
            if (users[i].age >= 30) {
                temp_users.push(users[i])
            }
        }
        console.log('temp_users: ', temp_users)

        // 2. 30세 이상인 users의 ages를 수집한다.

        var names = []
        for (var i = 0; i < temp_users.length; i++) {
            names.push(temp_users[i].name)
        }
        console.log('names: ', names)

        // 3. 30세 미만인 users를 거른다.
        var temp_users = []
        for (var i = 0; i < users.length; i++) {
            if (users[i].age < 30) {
                temp_users.push(users[i])
            }
        }
        console.log('temp_users: ', temp_users)
        // 4. 30세 미만인 users의 ages를 수집한다.

        var ages = []
        for (var i = 0; i < temp_users.length; i++) {
            ages.push(temp_users[i].age)
        }
        console.log('ages: ', ages)

        // 여기서 _filter와 같은 함수를 "응용형 함수라고 한다."(혹은 고차함수)
        // 함수가 함수를 받아서 원하는 시점에 평가하면서 해당하는 함수 안에서 알고 있는 특정한 인자를 적용해 나가며 로직을 완성하는 프로그래밍.
        // 응용형 프로그래밍, 적용형 프로그래밍.

        // 고차함수
        // 1. 함수를 인자로 받거나
        // 2. 함수를 리턴
        // 3. 함수안에서 인자로 받은 함수를 실행

        var over_30 = _filter(users, function (user) {
            return user.age >= 30
        })

        console.log('over_30: ', over_30)

        var over_30_names = _map(over_30, function (user) {
            return user.name
        })

        console.log('over_30_names: ', over_30_names)

        var under_30 = _filter(users, function (user) {
            return user.age < 30
        })

        console.log('under_30: ', under_30)

        var under_30_ages = _map(under_30, function (user) {
            return user.age
        })

        console.log('under_30_ages: ', under_30_ages)




        // 사실 함수형 프로그래밍에서는 대입문을 잘 사용하지 않는 경향을 띈다.
        // 원래 값을 만들어 놓고 문장을 내려가면서 변형하는게 아니라
        // 함수를 통과해 나가면서 한번에 값을 새롭게 만들어나가는 프로그래밍.
        // 대입문과 대입문 사이에 변형을 일으킬 소지가 적어진다.

        console.log('over_30_names',
            _map(
                _filter(users, function (user) {
                    return user.age >= 30
                }), function (user) {
                    return user.name
                })
        )

        console.log('under_30_ages',
            _map(
                _filter(users, function (user) {
                    return user.age < 30
                }), function (user) {
                    return user.age
                })
        )


        // console.log(_filter([1, 2, 3, 4], function (num) { return num % 2 }))
        // console.log(_filter([1, 2, 3, 4], function (num) { return !(num % 2) }))
        // console.log(_map([1, 2, 3], function (num) { return num * 2 }))


        // 3. each 만들기
        // 1. 


        // 여기서 내장된 map과 filter는 모두 Array 객체에 포함된 '메서드'이다.
        // 객체 지향
        console.log(
            [1, 2, 3, 4].map((val) => {
                return val * 2
            })
        )

        console.log(
            [1, 2, 3, 4].filter((val) => {
                return val % 2
            })
        )

        // 2. 외부 다형성(_map, _filter, _each와 같은 고차 함수의 구현에 따라 확보)
        // 1. array like, arguments, document.querySelectorAll

        // 오류
        // 유사 배열(array like)에는 map메소드가 내장되어 있지 않으므로.
        // console.log(
        //     document.querySelectorAll('*').map((node) => {
        //         return node.nodeName
        //     })
        // )

        // 우리의 _map함수는 높은 다형성 확보
        console.log(
            _map(document.querySelectorAll('*'), (node) => {
                return node.nodeName
            })
        )

        // 또한 함수형 프로그래밍은 객체 지향과 다르게 데이터가 있어야 메소드가 존재하는 것이 아닌(data.method~) 함수가 그 이전에 먼저 존재하기 때문에 평가시점이 비교적 자유롭다.


        // 3. 내부 다형성
        // 1. predi, iter, mapper가 확보.

        _map([1, 2, 3, 4], (v) => { // 콜백 함수라기 보다 보조 함수의 기능에 따라 이름을 붙여 다르게 불러주는게 좋다. 지금의 경우는 mapper 함수
            return v + 10   //  숫자니까 더할거라던지.(내부 데이터 형에 대한 이해)
        })

        var add = _curry(function (a, b) {
            return a + b
        })

        var add10 = add(10)
        var add5 = add(5)


        // add = function (a) {
        //     return function (b) {
        //         return function (a, b) {
        //             return a + b
        //         }
        //     }
        // }

        // add10 = function (b) {
        //     return function (10, b) {
        //         return 10 + b
        //     }
        // }

        // add10(5) = function (10, 5) {
        //     return 10 + 5
        // }

        console.log(add10(5))   // 15
        console.log(add(5)(3))  // 8
        console.log(add5(3))    // 8
        console.log(add(10)(3)) // 13
        console.log(add(1, 2))  // 3    // 인자 두개면 함수 본체 즉시 실행

        var sub = _curryr(function (a, b) {
            return a - b
        })

        console.log(sub(10, 5))

        var sub10 = sub(10)
        console.log(sub10(5))   // 표현에 맞게.



        var user1 = users[0]

        console.log(user1.name)
        console.log(_get(user1, 'name'))
        console.log(_get('name')(user1))

        var get_name = _get('name') // 이름을 꺼내는 함수가 된다.
        console.log(get_name(users[3])) // _curryr 함수를 이용해 다른 유저의 이름도 꺼내올 수 있는 함수가 된다.

        // console.log(users[10].name)  // console err
        // console.log(_get(users[10], 'name'))    // undefined


        console.log('over_30_names',
            _map(
                _filter(users, function (user) {
                    return user.age >= 30
                }), function (user) {
                    return user.name
                })
        )


        console.log('over_30_names',
            _map(
                _filter(users, function (user) { return user.age >= 30 }),
                _get('name'))
        )   // mapper 함수를 간결히 표현하게 됨.

        console.log('under_30_ages',
            _map(
                _filter(users, function (user) { return user.age < 30 }),
                _get('age'))
        )   // mapper 함수를 간결히 표현하게 됨.

        console.log(_get('name')({ name: 'seolran', age: 31 }))
        console.log(_get('age')({ name: 'seolran', age: 31 }))

        // 4. _reduce 만들기
        var slice = Array.prototype.slice
        function _rest(list, num) {
            return slice.call(list, num || 1)
        }
        function _reduce(list, iter, memo) {    // memo: 시작 값
            // return iter(iter(iter(0, 1), 2), 3)
            if (arguments.length == 2) {
                memo = list[0]
                // slice는 Array의 "메소드"이기 때문에 _reduce함수는 Array의 의존적인 함수가 되버린다.
                list = _rest(list)
            }
            _each(list, function (val) {
                memo = iter(memo, val)
            })
            return memo
        }

        console.log(
            _reduce([1, 2, 3], add, 0)
        )   // 6

        // 동작원리
        // memo = add(0, 1)
        // memo = add(memo, 2)
        // memo = add(memo, 3)
        // return memo

        // add(add(add0, 1), 2), 3)

        // reduce함수는 들어온 데이터를 축약된 형태로 return하기 위해 사용한다.
        // ex) array로 들어오지만 리듀스를 거쳐 숫자로 나오는


        console.log(
            _reduce([1, 2, 3], add) // 3번째 인자 생략
        )   // 6

    </script>
</body>

</html>